<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Back to Bare Metal: WSGI &amp; ASGI for Python Developers</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Django and FastAPI are just fancy callables. This book strips away the magic, shows you exactly what&#x27;s happening under the hood, and teaches you to build Python web apps from first principles — synchronous with WSGI, async with ASGI. Know your tools. Really know them.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-f264109a.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-b3b7d003.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Back to Bare Metal: WSGI &amp; ASGI for Python Developers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/cloudstreet-dev/Back-to-Bare-Metal-with-Python-WSGI-and-ASGI" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="the-lie-youve-been-living"><a class="header" href="#the-lie-youve-been-living">The Lie You’ve Been Living</a></h1>
<p>You’ve been writing Python web applications for — let’s say — a while. You know how to define routes. You know how to write views. You know that <code>request.method</code> gives you <code>"GET"</code> or <code>"POST"</code>, and you know that returning a <code>Response</code> object makes things appear in someone’s browser.</p>
<p>What you may not know is what any of that actually <em>is</em>.</p>
<p>Here is the thing that your framework would prefer you not examine too closely: it’s a function. The entire web application you’ve been building — the routing, the middleware, the template rendering, the session handling, the authentication system, the REST API — all of it ultimately compiles down to a Python callable that takes some arguments and returns something.</p>
<p>That’s it. That’s the whole trick.</p>
<h2 id="lets-prove-it-right-now"><a class="header" href="#lets-prove-it-right-now">Let’s Prove It Right Now</a></h2>
<p>Here is a complete, functional web application that will run in production:</p>
<pre><code class="language-python">def application(environ, start_response):
    status = "200 OK"
    headers = [("Content-Type", "text/plain")]
    start_response(status, headers)
    return [b"Hello, world"]
</code></pre>
<p>Save this as <code>app.py</code>. Install gunicorn (<code>pip install gunicorn</code>). Run:</p>
<pre><code class="language-bash">gunicorn app:application
</code></pre>
<p>You now have a production web server serving HTTP requests. No framework. No dependencies beyond gunicorn. No magic.</p>
<p>If you point your browser at <code>http://localhost:8000</code>, you’ll see “Hello, world”.</p>
<p>That function — <code>application</code> — is a WSGI application. Everything Django and Flask have ever done starts from exactly this interface.</p>
<h2 id="the-moment-of-recognition"><a class="header" href="#the-moment-of-recognition">The Moment of Recognition</a></h2>
<p>Now look at Django. From <code>django/core/handlers/wsgi.py</code>:</p>
<pre><code class="language-python">class WSGIHandler(base.BaseHandler):
    request_class = WSGIRequest

    def __call__(self, environ, start_response):
        set_script_prefix(get_script_name(environ))
        signals.request_started.send(sender=self.__class__, environ=environ)
        request = self.request_class(environ)
        response = self.get_response(request)
        # ... headers, status ...
        start_response(status, response_headers)
        # ...
        return response
</code></pre>
<p>It’s <code>__call__</code>. Django’s entire web framework is a class with a <code>__call__</code> method that takes <code>environ</code> and <code>start_response</code>. It is, by definition, a callable that implements the WSGI interface.</p>
<p>Every piece of Django — the ORM, the admin, the URL dispatcher, the template engine — exists to produce that callable. The callable is the product.</p>
<p>Flask? Same thing:</p>
<pre><code class="language-python">class Flask(App):
    def __call__(self, environ, start_response):
        return self.wsgi_app(environ, start_response)
</code></pre>
<p>FastAPI runs on top of Starlette, which is ASGI (we’ll get to that). But strip it down and you find the same idea: a callable with a defined interface.</p>
<h2 id="why-this-matters"><a class="header" href="#why-this-matters">Why This Matters</a></h2>
<p>If you understand that your framework is a callable with a specific signature, several things become clear:</p>
<p><strong>Testing becomes obvious.</strong> Your app is a function. Call it with the right arguments and inspect the result. No magic test client needed — though those are useful too.</p>
<p><strong>Middleware makes sense.</strong> Middleware is a callable that takes a callable and returns a callable. It’s function composition. It’s wrappers. Once you see this, the middleware stack is just a chain of decorators with extra steps.</p>
<p><strong>The framework is not special.</strong> It’s solving real problems — routing, request parsing, response serialization — but it’s doing so with the same Python you write every day. There’s no privileged access, no hidden C extensions doing the real work (well, sometimes there are C extensions, but not for routing). It’s just code.</p>
<p><strong>Debugging gets easier.</strong> When something goes wrong at the framework level, you now have a mental model of where to look. The request came in. It hit the WSGI callable. Something happened between <code>environ</code> and <code>start_response</code>. You can trace it.</p>
<h2 id="the-interfaces-briefly"><a class="header" href="#the-interfaces-briefly">The Interfaces, Briefly</a></h2>
<p>There are two specs we care about in this book.</p>
<p><strong>WSGI</strong> (Web Server Gateway Interface, PEP 3333) is the synchronous interface. It’s been around since 2003. Every line of Python web code written before async became mainstream runs on top of it. The entire spec is essentially:</p>
<pre><code>application(environ, start_response) -&gt; iterable of bytes
</code></pre>
<p><strong>ASGI</strong> (Asynchronous Server Gateway Interface) is the async successor. It was designed to handle things WSGI can’t — WebSockets, long-polling, HTTP/2 push — by making the entire interface async. The spec is:</p>
<pre><code>application(scope, receive, send) -&gt; None  # but async
</code></pre>
<p>Both specs define a contract between a <em>web server</em> (Gunicorn, Uvicorn, Hypercorn) and a <em>web application</em> (your code, or Django, or FastAPI). The server handles the TCP connection, parses the HTTP request, and calls your callable. Your callable decides what to return. The server sends it back.</p>
<p>The framework just makes it easier to write that callable. That’s the whole job.</p>
<h2 id="what-this-book-will-do"><a class="header" href="#what-this-book-will-do">What This Book Will Do</a></h2>
<p>We’re going to start at the bottom.</p>
<p>In Part I, we’ll look at what HTTP actually is (text over a socket), what the frameworks are doing, and why understanding this matters for your day-to-day work.</p>
<p>In Part II, we’ll implement WSGI from first principles: a server, middleware, routing, and request/response abstractions — all from scratch.</p>
<p>In Part III, we’ll do the same for ASGI: the async model, WebSockets, lifespan events, and building an async server.</p>
<p>In Part IV, we’ll look at patterns — testing, middleware composition, and building a small framework — to solidify everything.</p>
<p>By the end, you’ll be able to read the Gunicorn source code and understand what it’s doing. You’ll know what Uvicorn’s <code>main()</code> actually does. You’ll be able to debug framework-level issues because you’ll have written the framework-level code yourself.</p>
<p>More importantly, you’ll look at your next Django application and see it for what it is: a callable. A very sophisticated, well-tested, production-hardened callable — but a callable nonetheless.</p>
<p>The magic was just Python with good variable names.</p>
<p>Let’s start with the protocol.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="http-is-just-text"><a class="header" href="#http-is-just-text">HTTP Is Just Text</a></h1>
<p>Before we talk about WSGI or ASGI, we need to talk about what they’re abstracting over. And what they’re abstracting over is HTTP. And HTTP is just text.</p>
<p>This is not a simplification. Open a TCP connection to port 80 of any web server in the world, type the right bytes, and you’ll get an HTTP response. You don’t need a library. You need a socket and the knowledge of what to type.</p>
<p>Let’s actually do it.</p>
<h2 id="talking-to-a-web-server-with-a-raw-socket"><a class="header" href="#talking-to-a-web-server-with-a-raw-socket">Talking to a Web Server with a Raw Socket</a></h2>
<pre><code class="language-python">import socket

def raw_http_request(host: str, path: str = "/") -&gt; str:
    """Make an HTTP/1.1 GET request using nothing but a socket."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, 80))

    # This is a complete, valid HTTP/1.1 request.
    request = (
        f"GET {path} HTTP/1.1\r\n"
        f"Host: {host}\r\n"
        f"Connection: close\r\n"
        f"\r\n"
    )

    sock.sendall(request.encode("utf-8"))

    # Read the response in chunks
    response = b""
    while chunk := sock.recv(4096):
        response += chunk

    sock.close()
    return response.decode("utf-8", errors="replace")


if __name__ == "__main__":
    response = raw_http_request("example.com")
    print(response[:500])  # Just the beginning
</code></pre>
<p>Run this and you’ll see something like:</p>
<pre><code>HTTP/1.1 200 OK
Content-Encoding: gzip
Accept-Ranges: bytes
Age: 123456
Cache-Control: max-age=604800
Content-Type: text/html; charset=UTF-8
Date: Thu, 01 Jan 2026 00:00:00 GMT
...

&lt;!doctype html&gt;
&lt;html&gt;
...
</code></pre>
<p>That’s it. That’s HTTP. A text request, a text response. The format is specified in RFC 9110 (and historically RFC 2616, RFC 7230, etc.) but the format itself is not complicated.</p>
<h2 id="the-structure-of-an-http-request"><a class="header" href="#the-structure-of-an-http-request">The Structure of an HTTP Request</a></h2>
<p>An HTTP request has this shape:</p>
<pre><code>METHOD /path HTTP/version\r\n
Header-Name: header-value\r\n
Another-Header: another-value\r\n
\r\n
[optional body]
</code></pre>
<p>A minimal GET request:</p>
<pre><code>GET /index.html HTTP/1.1\r\n
Host: example.com\r\n
\r\n
</code></pre>
<p>A POST request with a body:</p>
<pre><code>POST /api/users HTTP/1.1\r\n
Host: api.example.com\r\n
Content-Type: application/json\r\n
Content-Length: 27\r\n
\r\n
{"name": "Alice", "age": 30}
</code></pre>
<p>Three parts: the request line, the headers, and the body. Each header is on its own line. Headers are separated from the body by a blank line (<code>\r\n\r\n</code>). The <code>\r\n</code> is a carriage return followed by a newline — HTTP requires both, not just <code>\n</code>.</p>
<h2 id="the-structure-of-an-http-response"><a class="header" href="#the-structure-of-an-http-response">The Structure of an HTTP Response</a></h2>
<p>An HTTP response:</p>
<pre><code>HTTP/version STATUS_CODE Reason Phrase\r\n
Header-Name: header-value\r\n
Another-Header: another-value\r\n
\r\n
[body]
</code></pre>
<p>A minimal response:</p>
<pre><code>HTTP/1.1 200 OK\r\n
Content-Type: text/plain\r\n
Content-Length: 13\r\n
\r\n
Hello, world!
</code></pre>
<p>The status line, headers, blank line, body. Same structure, mirrored.</p>
<h2 id="parsing-http-requests"><a class="header" href="#parsing-http-requests">Parsing HTTP Requests</a></h2>
<p>Let’s write a basic HTTP request parser. Not to use in production — for understanding what Gunicorn and Uvicorn do on every single request before they ever touch your application code.</p>
<pre><code class="language-python">from dataclasses import dataclass, field
from typing import Dict, Optional


@dataclass
class HTTPRequest:
    method: str
    path: str
    query_string: str
    http_version: str
    headers: Dict[str, str]
    body: bytes

    @property
    def content_type(self) -&gt; Optional[str]:
        return self.headers.get("content-type")

    @property
    def content_length(self) -&gt; int:
        return int(self.headers.get("content-length", 0))


def parse_request(raw: bytes) -&gt; HTTPRequest:
    """
    Parse a raw HTTP request into an HTTPRequest object.
    Handles the header/body split and basic header parsing.
    """
    # Split headers from body at the blank line
    header_section, _, body = raw.partition(b"\r\n\r\n")

    # Split header section into individual lines
    lines = header_section.decode("utf-8", errors="replace").split("\r\n")

    # First line is the request line
    request_line = lines[0]
    method, raw_path, http_version = request_line.split(" ", 2)

    # Split path from query string
    if "?" in raw_path:
        path, query_string = raw_path.split("?", 1)
    else:
        path, query_string = raw_path, ""

    # Parse headers (everything after the request line)
    headers = {}
    for line in lines[1:]:
        if ": " in line:
            name, _, value = line.partition(": ")
            headers[name.lower()] = value

    return HTTPRequest(
        method=method,
        path=path,
        query_string=query_string,
        http_version=http_version,
        headers=headers,
        body=body,
    )


# Test it
raw_request = (
    b"POST /api/users?active=true HTTP/1.1\r\n"
    b"Host: localhost\r\n"
    b"Content-Type: application/json\r\n"
    b"Content-Length: 27\r\n"
    b"\r\n"
    b'{"name": "Alice", "age": 30}'
)

req = parse_request(raw_request)
print(f"Method: {req.method}")
print(f"Path: {req.path}")
print(f"Query: {req.query_string}")
print(f"Content-Type: {req.content_type}")
print(f"Body: {req.body}")
</code></pre>
<p>Output:</p>
<pre><code>Method: POST
Path: /api/users
Query: active=true
Content-Type: application/json
Body: b'{"name": "Alice", "age": 30}'
</code></pre>
<p>This is, roughly, what every web server does before handing control to your application. Gunicorn’s HTTP parser is more robust (it handles edge cases, malformed requests, chunked transfer encoding, etc.), but conceptually it’s doing exactly this.</p>
<h2 id="building-an-http-response"><a class="header" href="#building-an-http-response">Building an HTTP Response</a></h2>
<p>The other direction: given what you want to send back, construct valid HTTP bytes.</p>
<pre><code class="language-python">def build_response(
    status_code: int,
    reason: str,
    headers: Dict[str, str],
    body: bytes,
) -&gt; bytes:
    """Build a raw HTTP/1.1 response."""
    status_line = f"HTTP/1.1 {status_code} {reason}\r\n"

    # Always include Content-Length
    headers["Content-Length"] = str(len(body))

    header_lines = "".join(
        f"{name}: {value}\r\n"
        for name, value in headers.items()
    )

    return (
        status_line.encode("utf-8")
        + header_lines.encode("utf-8")
        + b"\r\n"
        + body
    )


response = build_response(
    200,
    "OK",
    {"Content-Type": "text/plain"},
    b"Hello, world!",
)
print(response.decode("utf-8"))
</code></pre>
<p>Output:</p>
<pre><code>HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 13

Hello, world!
</code></pre>
<h2 id="what-wsgi-does-with-all-this"><a class="header" href="#what-wsgi-does-with-all-this">What WSGI Does With All This</a></h2>
<p>Now think about this: when a request comes in to a Gunicorn worker, the worker:</p>
<ol>
<li>Reads bytes from the socket</li>
<li>Parses them into method, path, headers, body (as above)</li>
<li>Packs all of that into a dictionary called <code>environ</code></li>
<li>Calls your WSGI application with <code>environ</code> and <code>start_response</code></li>
<li>Takes whatever your application returns and writes it back to the socket as HTTP response bytes</li>
</ol>
<p>The <code>environ</code> dictionary is just a structured version of the parsed HTTP request. <code>REQUEST_METHOD</code> is the method. <code>PATH_INFO</code> is the path. <code>HTTP_CONTENT_TYPE</code> is the Content-Type header. <code>wsgi.input</code> is a file-like object wrapping the body bytes.</p>
<p>When you call <code>start_response("200 OK", [("Content-Type", "text/plain")])</code> in your WSGI app, you’re providing the status line and headers that the server will write back. When you return <code>[b"Hello, world!"]</code>, you’re providing the response body.</p>
<p>The server just… sends it.</p>
<pre><code>[raw bytes in] -&gt; [parse] -&gt; [your callable] -&gt; [serialize] -&gt; [raw bytes out]
</code></pre>
<p>That’s the entire pipeline. WSGI is just the contract for the middle part.</p>
<h2 id="keepalive-chunked-encoding-and-things-were-ignoring"><a class="header" href="#keepalive-chunked-encoding-and-things-were-ignoring">Keepalive, Chunked Encoding, and Things We’re Ignoring</a></h2>
<p>Real HTTP has some complexity we’ve glossed over:</p>
<p><strong>Connection: keep-alive</strong> — HTTP/1.1 defaults to keeping the connection open for multiple requests. The server needs to know when one request ends and the next begins, which it does via <code>Content-Length</code> or chunked transfer encoding.</p>
<p><strong>Chunked transfer encoding</strong> — instead of specifying <code>Content-Length</code> upfront, you can stream the response in chunks, each prefixed with its size in hex. This is how streaming responses work.</p>
<p><strong>HTTP/2</strong> — multiplexed streams over a single connection, binary framing, header compression. Same semantics, very different wire format.</p>
<p><strong>TLS</strong> — everything above happens over an encrypted connection. Same protocol, but the bytes going over the wire are ciphertext.</p>
<p>WSGI abstracts all of this. You don’t handle keep-alive or chunked encoding directly. The server does. You write your callable; the server handles the transport.</p>
<p>ASGI handles more of these edge cases natively — particularly streaming — which is part of why it exists. We’ll get there.</p>
<h2 id="the-thing-to-hold-onto"><a class="header" href="#the-thing-to-hold-onto">The Thing to Hold Onto</a></h2>
<p>HTTP is a text protocol. Requests are lines of text: a request line, headers, body. Responses are lines of text: a status line, headers, body. The blank line between headers and body is significant. The <code>\r\n</code> line endings are required.</p>
<p>Everything your framework does is ultimately:</p>
<ol>
<li>Parse the incoming text into a convenient Python object</li>
<li>Call your handler function</li>
<li>Serialize the result back into text</li>
</ol>
<p>That’s the whole transaction. Hold that mental model as we build the WSGI layer on top of it.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="what-django-and-fastapi-are-actually-doing"><a class="header" href="#what-django-and-fastapi-are-actually-doing">What Django and FastAPI Are Actually Doing</a></h1>
<p>We’ve established that HTTP is text and that WSGI is a callable interface. Now let’s look at what Django and FastAPI actually do with that interface — because once you see it, the framework becomes a much less mysterious box.</p>
<p>We’ll trace a request through each one, following the actual code path (simplified to keep it readable). The goal is not to understand every detail of Django’s internals — the Django team has written excellent documentation for that. The goal is to see the skeleton: the WSGI entry point, the routing, and the response serialization.</p>
<h2 id="djangos-request-path"><a class="header" href="#djangos-request-path">Django’s Request Path</a></h2>
<p>A Django project has a WSGI entrypoint file, generated by <code>startproject</code>:</p>
<pre><code class="language-python"># myproject/wsgi.py
import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')

application = get_wsgi_application()
</code></pre>
<p><code>application</code> here is what Gunicorn will call. Let’s follow <code>get_wsgi_application()</code>:</p>
<pre><code class="language-python"># django/core/wsgi.py
def get_wsgi_application():
    django.setup()
    return WSGIHandler()
</code></pre>
<p>It runs Django setup (loads settings, connects signals, initializes apps) and returns a <code>WSGIHandler</code>. Let’s look at <code>WSGIHandler</code>:</p>
<pre><code class="language-python"># django/core/handlers/wsgi.py (simplified)
class WSGIHandler(base.BaseHandler):
    request_class = WSGIRequest

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.load_middleware()  # Build the middleware stack

    def __call__(self, environ, start_response):
        # Convert environ to a Django request object
        request = self.request_class(environ)

        # Run the full middleware/view pipeline
        response = self.get_response(request)

        # Django response -&gt; HTTP status string and headers list
        status = '%d %s' % (response.status_code, response.reason_phrase)
        response_headers = list(response.items())
        for c in response.cookies.values():
            response_headers.append(('Set-Cookie', c.output(header='')))

        # Tell the WSGI server what status and headers to use
        start_response(status, response_headers)

        # Return the response body as an iterable
        if request.method == 'HEAD':
            return [b'']
        return response
</code></pre>
<p>The <code>__call__</code> method is the WSGI application. It takes <code>environ</code> and <code>start_response</code>, does Django things, and returns a response iterable.</p>
<h3 id="the-middleware-stack"><a class="header" href="#the-middleware-stack">The Middleware Stack</a></h3>
<p><code>self.load_middleware()</code> builds a chain of callables. If your <code>MIDDLEWARE</code> setting looks like:</p>
<pre><code class="language-python">MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'myapp.middleware.CustomMiddleware',
]
</code></pre>
<p>Then <code>load_middleware()</code> constructs something conceptually like:</p>
<pre><code class="language-python">def _get_response_none(request):
    # The actual view dispatcher
    return view_function(request)

handler = _get_response_none
for middleware_path in reversed(MIDDLEWARE):
    middleware_class = import_string(middleware_path)
    handler = middleware_class(handler)

self._middleware_chain = handler
</code></pre>
<p>Each middleware wraps the next one. When you call <code>self.get_response(request)</code>, you’re calling <code>self._middleware_chain(request)</code>, which unwinds through each middleware layer until it hits the view. This is exactly the turtles-all-the-way-down middleware pattern we’ll implement ourselves in the WSGI section.</p>
<h3 id="the-url-dispatcher"><a class="header" href="#the-url-dispatcher">The URL Dispatcher</a></h3>
<p>Inside <code>get_response</code>, Django eventually calls:</p>
<pre><code class="language-python"># django/core/handlers/base.py (simplified)
def _get_response(self, request):
    callback, callback_args, callback_kwargs = self.resolve_request(request)
    response = callback(request, *callback_args, **callback_kwargs)
    return response
</code></pre>
<p><code>resolve_request</code> does URL routing: it takes <code>request.path_info</code> and walks through the <code>urlpatterns</code> list, matching regex patterns or path converters until it finds a match. The match returns the view function and any captured URL parameters.</p>
<p>That view function is what you write. Django calls it. You return an <code>HttpResponse</code>. Django serializes it. Done.</p>
<h2 id="fastapis-request-path"><a class="header" href="#fastapis-request-path">FastAPI’s Request Path</a></h2>
<p>FastAPI is an ASGI framework (we’ll cover ASGI in Part III), but the same “it’s just a callable” principle applies.</p>
<pre><code class="language-python">from fastapi import FastAPI

app = FastAPI()

@app.get("/users/{user_id}")
async def get_user(user_id: int):
    return {"user_id": user_id}
</code></pre>
<p><code>app</code> here is a FastAPI instance. FastAPI inherits from Starlette, which implements the ASGI interface. When Uvicorn calls your application:</p>
<pre><code class="language-python"># uvicorn calls this
await app(scope, receive, send)
</code></pre>
<p>Starlette’s <code>__call__</code> (simplified):</p>
<pre><code class="language-python">class Starlette:
    async def __call__(self, scope, receive, send):
        scope["app"] = self
        if self.middleware_stack is None:
            self.middleware_stack = self.build_middleware_stack()
        await self.middleware_stack(scope, receive, send)
</code></pre>
<p>Same pattern: a middleware stack, built once, called on every request.</p>
<p>At the bottom of the stack is the router. FastAPI’s router matches the path and HTTP method against registered routes, extracts path parameters, and calls your endpoint function.</p>
<h3 id="the-clever-part-dependency-injection-and-type-hints"><a class="header" href="#the-clever-part-dependency-injection-and-type-hints">The Clever Part: Dependency Injection and Type Hints</a></h3>
<p>The thing FastAPI adds is automatic parsing of function parameters using type hints. When you write:</p>
<pre><code class="language-python">@app.get("/items/{item_id}")
async def read_item(item_id: int, q: Optional[str] = None):
    return {"item_id": item_id, "q": q}
</code></pre>
<p>FastAPI uses <code>inspect.signature</code> to introspect the function, reads the type annotations, and automatically:</p>
<ul>
<li>Extracts <code>item_id</code> from the path (because it’s in the <code>{item_id}</code> path template)</li>
<li>Extracts <code>q</code> from the query string (because it’s not in the path)</li>
<li>Converts <code>item_id</code> to <code>int</code> and validates it</li>
<li>Returns a 422 if conversion fails</li>
</ul>
<p>This is done at startup (when the route is registered) using Pydantic and Python’s <code>inspect</code> module. There’s no magic — it’s reflection and type coercion applied systematically.</p>
<pre><code class="language-python"># What FastAPI is doing under the hood (very simplified)
import inspect
from typing import get_type_hints

def build_endpoint_handler(func):
    sig = inspect.signature(func)
    hints = get_type_hints(func)

    async def handler(scope, receive, send):
        # Extract path params, query params from scope
        path_params = scope.get("path_params", {})
        query_string = scope.get("query_string", b"").decode()

        # Build kwargs for the function
        kwargs = {}
        for name, param in sig.parameters.items():
            if name in path_params:
                kwargs[name] = hints[name](path_params[name])  # type coercion
            # ... query param extraction, body parsing, etc.

        result = await func(**kwargs)

        # Serialize result to JSON response
        # ...

    return handler
</code></pre>
<p>That’s the core of FastAPI’s “magic”. It’s Python’s <code>inspect</code> module and type coercion, applied at startup to build efficient request handlers.</p>
<h2 id="flasks-request-path"><a class="header" href="#flasks-request-path">Flask’s Request Path</a></h2>
<p>Flask is simpler than Django but uses the same WSGI interface. The <code>Flask</code> class has a <code>__call__</code> method:</p>
<pre><code class="language-python">class Flask:
    def __call__(self, environ, start_response):
        return self.wsgi_app(environ, start_response)

    def wsgi_app(self, environ, start_response):
        ctx = self.request_context(environ)
        ctx.push()
        try:
            response = self.full_dispatch_request()
            return response(environ, start_response)
        finally:
            ctx.pop()
</code></pre>
<p>Flask’s “request context” and “application context” are thread-local (or greenlet-local) storage — that’s how <code>flask.request</code> works without being passed as a parameter. When you access <code>request.method</code> in a Flask view, Flask looks up the current request from a thread-local stack that was pushed when <code>ctx.push()</code> was called.</p>
<p>This is convenient, but it’s not magic. It’s an implicit parameter passing mechanism. WSGI is synchronous and single-threaded-per-request, so thread-local storage works. This is also why Flask’s approach breaks down with async — thread-locals don’t survive across <code>await</code> points, which is one reason Flask’s async support required careful workarounds.</p>
<h2 id="what-they-all-have-in-common"><a class="header" href="#what-they-all-have-in-common">What They All Have in Common</a></h2>
<p>Every Python web framework, at its core, does this:</p>
<pre><code>environ/scope
    │
    ▼
┌─────────────────────────────────────────────────────┐
│ Middleware stack                                     │
│   ├── Security / CORS / compression / auth          │
│   ├── Session management                            │
│   └── (your middleware here)                        │
│         │                                           │
│         ▼                                           │
│ URL Router                                          │
│   └── match path → find handler function           │
│         │                                           │
│         ▼                                           │
│ Handler / View                                      │
│   └── your code runs here                          │
│         │                                           │
│         ▼                                           │
│ Response serialization                              │
│   └── status + headers + body → bytes              │
└─────────────────────────────────────────────────────┘
    │
    ▼
start_response(status, headers) + return [body_bytes]
</code></pre>
<p>The framework is providing:</p>
<ol>
<li>A way to compose middleware (the stack builder)</li>
<li>URL routing (pattern matching on <code>PATH_INFO</code>)</li>
<li>Request parsing (wrapping <code>environ</code> in a convenient object)</li>
<li>Response serialization (turning your return value into WSGI-compatible bytes)</li>
</ol>
<p>None of these are hard to understand. Some are hard to implement <em>well</em> — Django’s URL dispatcher handles edge cases you’d never think of, and FastAPI’s type coercion is quite sophisticated. But conceptually, they’re all doing the same four things.</p>
<h2 id="building-it-yourself"><a class="header" href="#building-it-yourself">Building It Yourself</a></h2>
<p>The rest of Part II is devoted to building each of these pieces from scratch. By the time we’re done, you’ll have:</p>
<ul>
<li>A working WSGI server</li>
<li>A middleware stack</li>
<li>A URL router</li>
<li>Request and Response classes</li>
</ul>
<p>None of it will be production-ready in the sense that Django is production-ready. But all of it will be <em>correct</em>, and building it will give you a ground-level understanding that reading the Django source code alone doesn’t provide.</p>
<p>The question isn’t “how does Django do routing?” The question is “what problem does routing solve, and what’s the simplest possible correct implementation?” Once you’ve answered the second question yourself, the first becomes easy to read.</p>
<p>Let’s start with the spec.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-wsgi-spec-it-fits-on-a-napkin"><a class="header" href="#the-wsgi-spec-it-fits-on-a-napkin">The WSGI Spec (It Fits on a Napkin)</a></h1>
<p>PEP 3333 is the WSGI specification. It is 2,500 words long. For context, this chapter is longer. The actual interface it defines is expressible in fewer than ten lines of Python. This is either a sign of elegant design or a sign that we’ve been dramatically over-complicating web development for twenty years. Possibly both.</p>
<p>Let’s read the spec together — not the full PEP, but the essential contract it defines.</p>
<h2 id="the-interface-in-full"><a class="header" href="#the-interface-in-full">The Interface in Full</a></h2>
<p>The complete WSGI interface, distilled:</p>
<pre><code class="language-python">def application(environ: dict, start_response: callable) -&gt; Iterable[bytes]:
    """
    A WSGI application is any callable that:
    1. Accepts environ (dict) and start_response (callable)
    2. Calls start_response(status, response_headers) exactly once before returning
    3. Returns an iterable of byte strings (the response body)
    """
    status = "200 OK"
    response_headers = [("Content-Type", "text/plain; charset=utf-8")]
    start_response(status, response_headers)
    return [b"Hello, world!\n"]
</code></pre>
<p>That’s it. That’s WSGI. Everything else is detail.</p>
<h2 id="the-environ-dictionary"><a class="header" href="#the-environ-dictionary">The <code>environ</code> Dictionary</a></h2>
<p><code>environ</code> is a Python dictionary containing CGI-style environment variables plus some WSGI-specific additions. When Gunicorn receives an HTTP request, it parses it and packs the results into this dict.</p>
<p>Here are the keys your application will actually use:</p>
<pre><code class="language-python"># Request method
environ['REQUEST_METHOD']    # "GET", "POST", "PUT", "DELETE", etc.

# URL components
environ['PATH_INFO']         # "/users/42" — the URL path
environ['QUERY_STRING']      # "active=true&amp;page=2" — without the "?"
environ['SERVER_NAME']       # "example.com"
environ['SERVER_PORT']       # "80" (note: string, not int)

# HTTP headers (prefixed with HTTP_, hyphens become underscores, uppercased)
environ['HTTP_HOST']                # "example.com"
environ['HTTP_ACCEPT']              # "text/html,application/xhtml+xml,..."
environ['HTTP_AUTHORIZATION']       # "Bearer abc123"
environ['HTTP_CONTENT_TYPE']        # Note: also available as CONTENT_TYPE (no HTTP_ prefix)
environ['CONTENT_TYPE']             # "application/json"
environ['CONTENT_LENGTH']           # "42" (string, or empty string if unknown)

# Request body
environ['wsgi.input']        # file-like object, read() to get the body bytes

# WSGI metadata
environ['wsgi.version']      # (1, 0)
environ['wsgi.url_scheme']   # "http" or "https"
environ['wsgi.multithread']  # True if server may run multiple threads
environ['wsgi.multiprocess'] # True if server may fork multiple processes
environ['wsgi.run_once']     # True if application will only be invoked once
environ['wsgi.errors']       # file-like object for error output (stderr)
</code></pre>
<p>Let’s write a small app that dumps the environ so you can see it for yourself:</p>
<pre><code class="language-python">import json


def environ_dumper(environ, start_response):
    """Dump the environ dict as JSON for debugging."""
    # Some values aren't JSON-serializable; convert them
    safe_environ = {}
    for key, value in sorted(environ.items()):
        if isinstance(value, (str, int, float, bool, type(None))):
            safe_environ[key] = value
        else:
            safe_environ[key] = f"&lt;{type(value).__name__}&gt;"

    body = json.dumps(safe_environ, indent=2).encode("utf-8")

    start_response("200 OK", [
        ("Content-Type", "application/json"),
        ("Content-Length", str(len(body))),
    ])
    return [body]


if __name__ == "__main__":
    from wsgiref.simple_server import make_server
    server = make_server("127.0.0.1", 8000, environ_dumper)
    print("Serving on http://127.0.0.1:8000")
    server.serve_forever()
</code></pre>
<p>Run this, hit <code>http://127.0.0.1:8000/some/path?foo=bar</code> in your browser, and you’ll see everything Gunicorn (or <code>wsgiref</code>) passes to your application. It demystifies a lot.</p>
<h2 id="the-start_response-callable"><a class="header" href="#the-start_response-callable">The <code>start_response</code> Callable</a></h2>
<p><code>start_response</code> is a callable provided by the server. Your application calls it to set the response status and headers. Its signature:</p>
<pre><code class="language-python">def start_response(
    status: str,              # e.g. "200 OK", "404 Not Found"
    response_headers: list,   # list of (name, value) tuples
    exc_info=None,            # for error handling, discussed below
) -&gt; write_callable:          # legacy write callable, don't use this
</code></pre>
<p>The <code>status</code> string must be a valid HTTP status: three digits, a space, and a reason phrase. The reason phrase can be anything — the spec doesn’t require it to be the canonical one — but convention is to use the standard phrases.</p>
<p>The <code>response_headers</code> is a list of <code>(name, value)</code> tuples. Names are case-insensitive in HTTP; convention is Title-Case. Values must be strings.</p>
<pre><code class="language-python"># Valid calls to start_response
start_response("200 OK", [
    ("Content-Type", "text/html; charset=utf-8"),
    ("X-Custom-Header", "my-value"),
])

start_response("404 Not Found", [
    ("Content-Type", "text/plain"),
])

start_response("302 Found", [
    ("Location", "https://example.com/new-url"),
    ("Content-Type", "text/plain"),
])
</code></pre>
<p><strong>The <code>write</code> callable</strong> that <code>start_response</code> returns is a legacy escape hatch for applications that need to write response data before returning from the callable. Don’t use it in new code. The spec includes it for backward compatibility with pre-WSGI CGI-style code.</p>
<h2 id="the-return-value"><a class="header" href="#the-return-value">The Return Value</a></h2>
<p>Your application must return an iterable of byte strings. Each item in the iterable is a chunk of the response body. The server will concatenate and send them.</p>
<pre><code class="language-python"># All of these are valid return values:

return [b"Hello, world!"]                         # Single chunk
return [b"Hello, ", b"world!"]                    # Multiple chunks
return iter([b"chunk 1", b"chunk 2"])             # Iterator
return (b"x" for x in range(3))                  # Generator

# For streaming responses, a generator is useful:
def streaming_app(environ, start_response):
    start_response("200 OK", [("Content-Type", "text/plain")])
    def generate():
        for i in range(100):
            yield f"Line {i}\n".encode("utf-8")
    return generate()
</code></pre>
<p>One important constraint: <strong>you must call <code>start_response</code> before (or while) the server is consuming your return iterable</strong>. In practice, call it before you return. The server will call <code>next()</code> on your iterable to get chunks, and by that point it needs to know the status and headers.</p>
<h2 id="the-close-method"><a class="header" href="#the-close-method">The <code>close()</code> Method</a></h2>
<p>If your return iterable has a <code>close()</code> method, the server will call it when it’s done — even if an exception occurred during iteration. This is how you ensure cleanup (open file handles, database connections, etc.) happens even when the response is only partially sent.</p>
<pre><code class="language-python">class FileResponse:
    def __init__(self, filepath):
        self.f = open(filepath, "rb")

    def __iter__(self):
        while chunk := self.f.read(8192):
            yield chunk

    def close(self):
        self.f.close()  # Server will call this


def file_serving_app(environ, start_response):
    path = environ['PATH_INFO'].lstrip('/')
    response = FileResponse(path)
    start_response("200 OK", [("Content-Type", "application/octet-stream")])
    return response
</code></pre>
<h2 id="error-handling-with-exc_info"><a class="header" href="#error-handling-with-exc_info">Error Handling with <code>exc_info</code></a></h2>
<p>If an error occurs after <code>start_response</code> has been called (and headers may have been sent), you can call <code>start_response</code> again with <code>exc_info</code> set. This is how middleware propagates exceptions:</p>
<pre><code class="language-python">import sys

def application(environ, start_response):
    try:
        # ... do work ...
        start_response("200 OK", [("Content-Type", "text/plain")])
        return [b"OK"]
    except Exception:
        start_response("500 Internal Server Error",
                       [("Content-Type", "text/plain")],
                       sys.exc_info())  # Pass exception info
        return [b"Internal Server Error"]
</code></pre>
<p>If headers haven’t been sent yet, the server will use the new status/headers. If headers have already been sent (which can happen with streaming responses), the server will re-raise the exception — there’s nothing else it can do at that point.</p>
<h2 id="what-the-server-side-looks-like"><a class="header" href="#what-the-server-side-looks-like">What the Server Side Looks Like</a></h2>
<p>To fully understand the contract, it helps to see what the server-side caller looks like. Here’s a minimal version:</p>
<pre><code class="language-python">def call_wsgi_app(app, environ):
    """
    Call a WSGI app and collect the response.
    Returns (status, headers, body_bytes).
    """
    response_started = []

    def start_response(status, headers, exc_info=None):
        if exc_info:
            try:
                if response_started:
                    raise exc_info[1].with_traceback(exc_info[2])
            finally:
                exc_info = None
        response_started.append((status, headers))

    result = app(environ, start_response)

    try:
        body = b"".join(result)
    finally:
        if hasattr(result, "close"):
            result.close()

    status, headers = response_started[0]
    return status, headers, body
</code></pre>
<p>This is what Gunicorn’s worker essentially does — before sending it back over the socket as HTTP bytes. Note how <code>start_response</code> just stores the status and headers; the actual sending happens after <code>app()</code> returns.</p>
<h2 id="the-complete-spec-annotated"><a class="header" href="#the-complete-spec-annotated">The Complete Spec, Annotated</a></h2>
<p>Here’s the one-page summary of everything WSGI requires:</p>
<pre><code>APPLICATION:
- Must be callable
- Takes two arguments: environ (dict), start_response (callable)
- Must call start_response(status, headers) exactly once
  (or on error, may call it again with exc_info)
- Must return an iterable of byte strings
- The iterable may have a close() method; if so, server must call it

ENVIRON:
- Must contain CGI/1.1 variables (REQUEST_METHOD, PATH_INFO, etc.)
- Must contain wsgi.input (readable file-like object for body)
- Must contain wsgi.errors (writable file-like for errors)
- Must contain wsgi.version (1, 0)
- Must contain wsgi.url_scheme ("http" or "https")
- Must contain wsgi.multithread, wsgi.multiprocess, wsgi.run_once (bools)
- HTTP headers: prefixed with HTTP_, hyphens→underscores, uppercased
  Exception: Content-Type and Content-Length have no HTTP_ prefix

START_RESPONSE:
- Takes status (str), response_headers (list of 2-tuples), exc_info (optional)
- Status format: "NNN Reason Phrase"
- Headers: list of (name, value) tuples, strings only
- Returns a write() callable (legacy; don't use)
- May be called again only if exc_info is provided

SERVER:
- Must call app(environ, start_response) to get response
- Must send status and headers before body
- Must call result.close() if it exists, even on error
- Must handle chunked responses (iterate over return value)
</code></pre>
<p>That’s the contract. Two functions talking to each other with a well-defined interface. The server provides <code>environ</code> and <code>start_response</code>; your app provides the response.</p>
<p>In the next chapter, we’ll write a real WSGI application — no <code>wsgiref</code>, no framework, just the spec and a server call.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="your-first-wsgi-app-no-training-wheels"><a class="header" href="#your-first-wsgi-app-no-training-wheels">Your First WSGI App (No Training Wheels)</a></h1>
<p>Let’s build something real. Not “hello world” (we did that in the introduction) — a genuinely useful WSGI application with multiple routes, request parsing, and proper response handling. All without a framework.</p>
<p>By the end of this chapter you’ll have a working JSON API that you can run with Gunicorn. It won’t be pretty. That’s the point.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>We’re building a simple in-memory task management API. It will support:</p>
<ul>
<li><code>GET /tasks</code> — list all tasks</li>
<li><code>POST /tasks</code> — create a task</li>
<li><code>GET /tasks/{id}</code> — get a specific task</li>
<li><code>DELETE /tasks/{id}</code> — delete a task</li>
</ul>
<p>That’s enough to demonstrate routing, request body parsing, path parameter extraction, and proper HTTP response semantics without drowning in incidental complexity.</p>
<h2 id="reading-the-request-body"><a class="header" href="#reading-the-request-body">Reading the Request Body</a></h2>
<p>The first thing most tutorials skip over: how do you read the request body in WSGI?</p>
<pre><code class="language-python">def read_body(environ) -&gt; bytes:
    """Read the request body from environ['wsgi.input']."""
    try:
        content_length = int(environ.get('CONTENT_LENGTH', 0) or 0)
    except (ValueError, TypeError):
        content_length = 0

    if content_length &gt; 0:
        return environ['wsgi.input'].read(content_length)
    return b''
</code></pre>
<p>Why <code>or 0</code>? Because <code>CONTENT_LENGTH</code> might be an empty string (<code>""</code>), which <code>int()</code> can’t convert. The <code>or 0</code> handles that case. Why the try/except? Because you can’t fully trust incoming headers.</p>
<p>Why <code>read(content_length)</code> rather than just <code>read()</code>? The spec says <code>wsgi.input</code> may be a socket-backed stream. Calling <code>read()</code> without a limit might block indefinitely waiting for a connection that never closes. Always read exactly <code>Content-Length</code> bytes.</p>
<h2 id="parsing-json-bodies"><a class="header" href="#parsing-json-bodies">Parsing JSON Bodies</a></h2>
<pre><code class="language-python">import json
from typing import Any, Optional


def parse_json_body(environ) -&gt; Optional[Any]:
    """Parse a JSON request body, returning None if absent or invalid."""
    content_type = environ.get('CONTENT_TYPE', '')
    if 'application/json' not in content_type:
        return None

    body = read_body(environ)
    if not body:
        return None

    try:
        return json.loads(body)
    except json.JSONDecodeError:
        return None
</code></pre>
<h2 id="building-responses"><a class="header" href="#building-responses">Building Responses</a></h2>
<p>Rather than calling <code>start_response</code> directly everywhere, let’s build a small helper:</p>
<pre><code class="language-python">def json_response(start_response, data: Any, status: int = 200) -&gt; list[bytes]:
    """Send a JSON response."""
    STATUS_PHRASES = {
        200: "OK",
        201: "Created",
        400: "Bad Request",
        404: "Not Found",
        405: "Method Not Allowed",
        500: "Internal Server Error",
    }
    body = json.dumps(data, indent=2).encode("utf-8")
    phrase = STATUS_PHRASES.get(status, "Unknown")
    start_response(
        f"{status} {phrase}",
        [
            ("Content-Type", "application/json"),
            ("Content-Length", str(len(body))),
        ]
    )
    return [body]
</code></pre>
<h2 id="the-application"><a class="header" href="#the-application">The Application</a></h2>
<p>Now the actual application. Notice the structure: it’s just a function that dispatches based on method and path.</p>
<pre><code class="language-python">import json
import re
import uuid
from typing import Any, Optional


# In-memory store
tasks: dict[str, dict] = {}


def read_body(environ) -&gt; bytes:
    try:
        content_length = int(environ.get('CONTENT_LENGTH', 0) or 0)
    except (ValueError, TypeError):
        content_length = 0
    if content_length &gt; 0:
        return environ['wsgi.input'].read(content_length)
    return b''


def parse_json_body(environ) -&gt; Optional[Any]:
    content_type = environ.get('CONTENT_TYPE', '')
    if 'application/json' not in content_type:
        return None
    body = read_body(environ)
    if not body:
        return None
    try:
        return json.loads(body)
    except json.JSONDecodeError:
        return None


STATUS_PHRASES = {
    200: "OK", 201: "Created", 400: "Bad Request",
    404: "Not Found", 405: "Method Not Allowed",
}


def json_response(start_response, data: Any, status: int = 200) -&gt; list[bytes]:
    body = json.dumps(data, indent=2).encode("utf-8")
    phrase = STATUS_PHRASES.get(status, "Unknown")
    start_response(
        f"{status} {phrase}",
        [("Content-Type", "application/json"),
         ("Content-Length", str(len(body)))]
    )
    return [body]


def application(environ, start_response):
    method = environ['REQUEST_METHOD']
    path = environ['PATH_INFO']

    # Route: GET /tasks
    if path == '/tasks' and method == 'GET':
        return json_response(start_response, list(tasks.values()))

    # Route: POST /tasks
    if path == '/tasks' and method == 'POST':
        data = parse_json_body(environ)
        if not data or 'title' not in data:
            return json_response(start_response,
                                 {"error": "title is required"}, 400)
        task = {
            "id": str(uuid.uuid4()),
            "title": data['title'],
            "done": False,
        }
        tasks[task['id']] = task
        return json_response(start_response, task, 201)

    # Route: /tasks/{id}
    match = re.fullmatch(r'/tasks/([^/]+)', path)
    if match:
        task_id = match.group(1)

        if method == 'GET':
            task = tasks.get(task_id)
            if task is None:
                return json_response(start_response,
                                     {"error": "not found"}, 404)
            return json_response(start_response, task)

        if method == 'DELETE':
            if task_id not in tasks:
                return json_response(start_response,
                                     {"error": "not found"}, 404)
            deleted = tasks.pop(task_id)
            return json_response(start_response, deleted)

        return json_response(start_response,
                             {"error": "method not allowed"}, 405)

    # 404 for everything else
    return json_response(start_response, {"error": "not found"}, 404)


if __name__ == '__main__':
    from wsgiref.simple_server import make_server
    print("Serving on http://127.0.0.1:8000")
    with make_server('127.0.0.1', 8000, application) as server:
        server.serve_forever()
</code></pre>
<p>Save this as <code>tasks_app.py</code> and run it:</p>
<pre><code class="language-bash">python tasks_app.py
</code></pre>
<p>Or with Gunicorn:</p>
<pre><code class="language-bash">pip install gunicorn
gunicorn tasks_app:application
</code></pre>
<h2 id="trying-it-out"><a class="header" href="#trying-it-out">Trying It Out</a></h2>
<pre><code class="language-bash"># Create a task
curl -X POST http://localhost:8000/tasks \
  -H "Content-Type: application/json" \
  -d '{"title": "Learn WSGI"}'
# {"id": "abc-123", "title": "Learn WSGI", "done": false}

# List tasks
curl http://localhost:8000/tasks
# [{"id": "abc-123", "title": "Learn WSGI", "done": false}]

# Get a specific task
curl http://localhost:8000/tasks/abc-123
# {"id": "abc-123", "title": "Learn WSGI", "done": false}

# Delete a task
curl -X DELETE http://localhost:8000/tasks/abc-123
# {"id": "abc-123", "title": "Learn WSGI", "done": false}

# Missing title
curl -X POST http://localhost:8000/tasks \
  -H "Content-Type: application/json" \
  -d '{"description": "oops"}'
# {"error": "title is required"}

# Not found
curl http://localhost:8000/tasks/nonexistent
# {"error": "not found"}
</code></pre>
<p>It works. No framework involved. The routing is regex matching on <code>PATH_INFO</code>. The request parsing is reading from <code>wsgi.input</code>. The responses are byte strings with proper headers.</p>
<h2 id="what-this-reveals-about-frameworks"><a class="header" href="#what-this-reveals-about-frameworks">What This Reveals About Frameworks</a></h2>
<p>Look at our <code>application</code> function and notice what’s getting tedious:</p>
<ol>
<li><strong>Routing</strong>: <code>if path == '/tasks' and method == 'GET'</code> — this will get unreadable fast</li>
<li><strong>Response construction</strong>: <code>json_response(start_response, data, status)</code> — we’re passing <code>start_response</code> everywhere</li>
<li><strong>Request parsing</strong>: <code>parse_json_body(environ)</code> — repeated on every endpoint that accepts a body</li>
<li><strong>Error handling</strong>: every route independently returns error responses</li>
</ol>
<p>A framework solves these problems. Flask gives you <code>@app.route('/tasks', methods=['GET'])</code>. Django gives you URL patterns and view functions. FastAPI gives you type annotations and automatic parsing.</p>
<p>But now you know what they’re solving. The <code>@app.route</code> decorator is just adding your function to a routing table and wrapping it so it conforms to the WSGI interface. The request object (<code>flask.request</code>, <code>django.request</code>) is just a wrapper around <code>environ</code>. The response class is a wrapper around <code>start_response</code> and the return value.</p>
<p>It’s convenience all the way down.</p>
<h2 id="the-wsgiref-module"><a class="header" href="#the-wsgiref-module">The <code>wsgiref</code> Module</a></h2>
<p>Python’s standard library includes <code>wsgiref</code>, a reference implementation of a WSGI server:</p>
<pre><code class="language-python">from wsgiref.simple_server import make_server
from wsgiref.validate import validator

# Wrap your app with the validator to catch WSGI spec violations
validated_app = validator(application)

with make_server('127.0.0.1', 8000, validated_app) as server:
    server.serve_forever()
</code></pre>
<p><code>wsgiref.validate.validator</code> wraps your application and checks that it correctly implements the WSGI spec — proper return types, calling <code>start_response</code> at the right time, etc. Use it during development; remove it for production.</p>
<p><code>wsgiref.simple_server</code> is not production-ready (it’s single-threaded and handles one request at a time), but it’s useful for local development when you want zero dependencies.</p>
<h2 id="on-state-and-concurrency"><a class="header" href="#on-state-and-concurrency">On State and Concurrency</a></h2>
<p>The <code>tasks</code> dictionary in our app is module-level state. This works fine for a single-process server, but Gunicorn’s default is to use multiple worker processes. Each worker has its own copy of the module, its own <code>tasks</code> dict. Changes in worker 1 are invisible to worker 2.</p>
<p>For production, you’d use a database or shared cache (Redis) instead of in-memory state. This isn’t a WSGI limitation — it’s just how multi-process architectures work. But it’s worth being explicit about: WSGI does not share state between requests. Each call to <code>application()</code> is independent.</p>
<p>This is actually a feature. It makes WSGI applications easy to reason about and easy to scale horizontally. Stateless by default.</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<p>Before moving on, try these modifications to the app:</p>
<ol>
<li>Add a <code>PATCH /tasks/{id}</code> endpoint that updates the <code>done</code> field</li>
<li>Add proper <code>Content-Type</code> validation — return 415 if it’s not <code>application/json</code> on POST</li>
<li>Add a request logger: print method, path, and status code for every request</li>
<li>Handle <code>PATCH /tasks/{id}</code> — change the <code>done</code> field</li>
</ol>
<p>Exercise 3 is a preview of the next chapter. The logging belongs in middleware.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="build-a-wsgi-server-from-scratch"><a class="header" href="#build-a-wsgi-server-from-scratch">Build a WSGI Server from Scratch</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="middleware-turtles-all-the-way-down"><a class="header" href="#middleware-turtles-all-the-way-down">Middleware: Turtles All the Way Down</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="routing-without-a-framework"><a class="header" href="#routing-without-a-framework">Routing Without a Framework</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="request-and-response-objects-diy-edition"><a class="header" href="#request-and-response-objects-diy-edition">Request and Response Objects (DIY Edition)</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="why-wsgi-cant-have-nice-things"><a class="header" href="#why-wsgi-cant-have-nice-things">Why WSGI Can’t Have Nice Things</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-asgi-spec"><a class="header" href="#the-asgi-spec">The ASGI Spec</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="your-first-asgi-app"><a class="header" href="#your-first-asgi-app">Your First ASGI App</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="build-an-asgi-server-from-scratch"><a class="header" href="#build-an-asgi-server-from-scratch">Build an ASGI Server from Scratch</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lifespan-events"><a class="header" href="#lifespan-events">Lifespan Events</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="websockets-over-asgi"><a class="header" href="#websockets-over-asgi">WebSockets Over ASGI</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="asgi-middleware-deep-dive"><a class="header" href="#asgi-middleware-deep-dive">ASGI Middleware Deep Dive</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="testing-wsgi-and-asgi-apps-without-a-framework"><a class="header" href="#testing-wsgi-and-asgi-apps-without-a-framework">Testing WSGI and ASGI Apps Without a Framework</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="roll-your-own-mini-framework"><a class="header" href="#roll-your-own-mini-framework">Roll Your Own Mini-Framework</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="you-know-too-much-now"><a class="header" href="#you-know-too-much-now">You Know Too Much Now</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
